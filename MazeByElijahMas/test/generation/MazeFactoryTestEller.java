package generation;

import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import gui.Controller;
import generation.Order;
import generation.OrderStub;

/**
 * 
 * <p>MazeFactoryTestEller tests the validity of a maze generated by Eller's algorithm
 * via MazeBuilderEller.
 * It inherits black-box tests from MazeFactoryTest and supplements these
 * by enabling white-box testing via in-line assertion statements inside
 * MazeBuilderEller.</p>
 * 
 * <p>JUnit {@code params} ({@code org.junit.jupiter.params}) is used
 * to automate application of test cases to mazes of variable difficulty levels.</p>
 * 
 * @author Elijah Mas
 *
 */
public class MazeFactoryTestEller extends MazeFactoryTest {
	
	/**
	 * Order that produced {@code perfectMaze}.
	 */
	OrderStub orderPerfect;
	
	/**
	 * Order that produced {@code imperfectMaze}.
	 */
	OrderStub orderImperfect;
	
	/**
	 * Builder that produced {@code perfectMaze}.
	 */
	MazeBuilderEller builderPerfect;
	
	/**
	 * Builder that produced {@code imperfectMaze}.
	 */
	MazeBuilderEller builderImperfect;
	
	/**
	 * Stores the level of the mazes currently being tests.
	 */
	int mazeLevel;
	
	/**
	 * <p>This method might be considered a stand-in "main" method for this class.
	 * It automates the execution of other methods that contain assert* statements
	 * but are not marked with the &#64;{@code Test} annotation; the reason for doing this is
	 * that this method uses the &#64;{@code ParameterizedTest} annotation, which allows
	 * all the other methods to be run with variable input arguments,
	 * which the plain &#64;{@code Test} annotation does not permit.
	 * The parameter values (&#64;{@code ValueSource}) are a series of integers that represent
	 * the different difficulty levels of puzzles involved that will be tested.</p>
	 * 
	 * <p><b>Call hierarchy</b></p>
	 * <p> There are different levels of tests conducted. First, there are tests defined
	 * by the {@link generation.MazeFactoryTest} and {@link generation.MazeFactoryTestEller}
	 * classes:
	 * <ul>
	 *    <li> {@link #allTests()}
	 *       <ul>
	 *       <li> {@link #baselineTests()}
	 *          <ul>
	 *          <li> {@link #testNoRoomsInPerfectMaze()}: test that a perfect maze has no rooms.</li>
	 *          <li> {@link #testOneExitByBorders()}: test that a maze has only one missing border around the periphery.</li>
	 *          <li> {@link #testExitAtExpectedLocation()}: test that the exit location identified
	 *               by a maze matches that which is detected by examining other maze properties.</li>
	 *          <li> {@link #testOneExitByDistance()}: test that only one maze cell has a distance of 1 to the exit.</li>
	 *          <li> {@link #testMaxDistanceStartingPoint()}: test that the starting point has the maximal distance
	 *               to the exit of all cells in the maze.</li>
	 *          <li> {@link #testEveryCellHasExit()} test that every cell has neighbors at distance=1 away and
	 *               with no floorboards in between, which allows us to conclude that every cell in the maze
	 *               can access the exit.</li>
	 *          </ul>
	 *       </li>
	 *       <li> {@link #deterministicTest(boolean) deterministicTest} ensure that the seed of the
	 *            random number generator is the same before each deterministic maze order. </li>
	 *       <li> {@link #testCells()} Eller specific: test that all cells in the maze's set cells
	 *            have value 1 when the algorithm concludes. </li>
	 *       <li> {@link #testCellSets()} Eller specific: test that the set of cell sets has only
	 *            one member when the algorithm concludes. </li>
	 *       </ul>
	 *    </li>
	 * </ul>
	 * </p>
	 * <br>
	 * <p>This method additionally calls tests embedded in the MazeBulderEller class under
	 * assertion statements. There are two branches of tests in that class:
	 * <ul>
	 *    <li> tests that run whenever VM -ea assertion is enabled </li>
	 *    <li> tests that run when VM -ea assertion is enabled
	 *         &amp;&amp; {@link generation.MazeBuilderEller#ENABLE_TESTS}{@code =true}. </li>
	 * </ul>
	 * </p>
	 * <p>Each one of these tests is run at the specified difficulty levels (currently 0-7);
	 * at each difficulty level we run all the above tests for four cases,
	 * save for {@link #testNoRoomsInPerfectMaze()}:
	 * <ol>
	 *    <li> a perfect maze </li>
	 *    <li> an imperfect maze where rooms are handled dynamically by Eller's algorithm</li>
	 *    <li> a perfect maze (again) </li>
	 *    <li> an imperfect maze where rooms are ignored by Eller's algorithm until it has iterated
	 *         through all rows, at which point rooms are retroactively opened up</li>
	 * </ol>
	 * As implied by the name, {@link #testNoRoomsInPerfectMaze()} is run only for a perfect maze.</p>
	 * <br>
	 * <p>Test 3 is redundant from test 1, but undoing that redundancy is more effort at the moment than
	 * worthwhile. Tests 2 and 4 check an important distinction. Test 2 reflects the operation of the
	 * normal Maze application: rooms are handled at each row as the algorithm progresses, and their
	 * walls are randomly opened. There is a small but nonzero chance that, because randomization is
	 * involved, a room will stand completely unopened after Eller's algorithm iterates over it.
	 * This is a corner case that must be handled. Test 4 forces this corner case to occur in a testing
	 * environment, to make sure that in the unlikely event it occurs in client-side use,
	 * it will be handled correctly.
	 *  
	 * @param level the difficulty level of the maze
	 */
	@ParameterizedTest
	@ValueSource(ints = {0,1,2,3,4,5,6,7})//
	@Override
	public void runAllTests(int level) {
		MazeBuilderEller.ENABLE_TESTS=true;
		System.out.println("\n\n*   *   *   Eller: level="+level);
		
		// run tests normally
		establishMazes(level, true, false);
		
		allTests();
	
		// run tests with room handling postponed in imperfect mazes
		establishMazes(level, true, true);
		
		allTests();
	}
	
	public void establishMazes(int level, boolean deterministic, boolean ignoreRooms) {
		perfectMaze=getMaze(true,deterministic,level,false);
		imperfectMaze=getMaze(false,deterministic,level,ignoreRooms);
		mazeLevel=level;
		
		if(null==perfectMaze || null==imperfectMaze) {
			throw new RuntimeException("MazeFactoryTest.establishMazes: the maze order is not successful");
		}
		
		//mazes have same dimensions
		width=perfectMaze.getWidth();
		height=perfectMaze.getHeight();
		
	}
	/**
	 * Adds new methods to the suite of tests for Eller's algorithm
	 * beyond those specified in #{@link #baselineTests()}.
	 */
	@Override
	public void allTests() {
		baselineTests();
		testCells();
		testCellSets();
	}
	
	//@Override
	public Maze getMaze(boolean perfect, boolean deterministic, int level, boolean ignoreRooms){
		
		Controller controller = new Controller();
		controller.turnOffGraphics();
		
		OrderStub order = new OrderStub();
		order.setSkillLevel(level);
		order.setBuilder(Order.Builder.Eller); 
		order.setPerfect(perfect);
		order.start(controller, null);
		
		MazeBuilderEller builder = new MazeBuilderEller(deterministic);
		deterministicTest(deterministic);
		
		if(ignoreRooms) builder.setToIgnoreRooms();
		builder.buildOrder(order);
		Thread buildThread = new Thread(builder);
		buildThread.start();
		try {
			buildThread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
			return null;
		}
		
		if(perfect) {
			this.orderPerfect=order;
			this.builderPerfect = builder;
		} else {
			this.orderImperfect=order;
			this.builderImperfect = builder;
		}
		
		System.out.println("100");
		
		return order.getMaze();
	}
	
	/**
	 * Tests that all maze cells belong to a single set
	 * by checking the array holding set values.
	 * Calls {@link #_testCells(MazeBuilderEller)}.
	 */
	public void testCells() {
		_testCells(builderPerfect);
		_testCells(builderImperfect);
	}

	/**
	 * Checks that all cells in the maze belong to the set with id=1,
	 * as prescribed by this implementation of Eller's algorithm.
	 * If any cell is found with any other value, return false.
	 * 
	 * <b>***Expected result:</b> all cells contain 1.
	 * 
	 * @param builder a MazeBuilderEller Instance
	 * @return boolean that is true if the test is successful.
	 */
	public boolean _testCells(MazeBuilderEller builder) {
		for(int[] row: builder.retrieve_cells()) {
			for(int v: row) {
				if(1!=v) return false;
			}
		}
		return true;
	}
	
	/**
	 * Tests that all maze cells belong to a single set
	 * by checking the array holding set values.
	 * Calls {@link #_testCellSets(MazeBuilderEller)}.
	 */
	public void testCellSets() {
		_testCellSets(builderPerfect);
		_testCellSets(builderImperfect);
	}
	
	/**
	 * Checks that there is only one set of cells identified in the maze,
	 * that the id of this set is 1, and that all cells in the maze are contained
	 * in this set.
	 * @param builder a MazeBuilderEller instance
	 * @return boolean that confirms the check
	 */
	public boolean _testCellSets(MazeBuilderEller builder) {
		@SuppressWarnings("unchecked")
		HashMap<Integer,Set<List<Integer>>> sets = builder.retrieve_cellSets();
		
		// test only one set present
		assertTrue(1==sets.keySet().size());
		
		// test that the set's id is 1
		assertTrue(sets.keySet().contains(1));
		
		Set<List<Integer>> set1 = (Set<List<Integer>>)sets.get(1);
		
		// test that this set is of the expected size (total # of maze cells)
		assertEquals(width*height,set1.size());
		
		// test that every maze cell is indeed in this set
		boolean check = true;
		for(int x=0; x<width; x++) {
			for(int y=0; y<height; y++) {
				if(!set1.contains(Arrays.asList(x,y))) {
					check=false;
					break;
				}
			}
		}
		assertTrue(check);
		
		// we could also check that there are no cells in the set that are out of bounds
		// but the above two tests guarantee that this is so
		
		return true;
	}

}
